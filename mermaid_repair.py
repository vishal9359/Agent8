"""
Mermaid Repair Module.
Automatically fixes common issues in generated Mermaid code.
Works generically for any C++ project without hardcoding.
"""

import re
from typing import List, Tuple, Optional, Dict, Set


class MermaidRepair:
    """Repair and fix common issues in Mermaid flowcharts."""
    
    def __init__(self):
        """Initialize Mermaid repair module."""
        pass
    
    def repair(self, mermaid_code: str) -> str:
        """
        Repair Mermaid code by fixing common issues.
        Optimized for performance with strict size limits.
        
        Args:
            mermaid_code: Potentially broken Mermaid code
            
        Returns:
            Repaired Mermaid code
        """
        if not mermaid_code or not mermaid_code.strip():
            return self._generate_empty_flowchart()
        
        # Remove markdown code blocks if present
        mermaid_code = self._clean_markdown(mermaid_code)
        
        # Ensure it starts with flowchart TD
        if not mermaid_code.strip().startswith("flowchart"):
            mermaid_code = "flowchart TD\n" + mermaid_code
        
        # STRICT SIZE LIMIT - Skip expensive repairs on large files
        # Large files are likely malformed and should be regenerated by LLM
        lines = mermaid_code.split("\n")
        line_count = len([l for l in lines if l.strip()])
        
        # If code is too large, do minimal repair only
        if line_count > 300:
            # Only do essential fixes - skip expensive operations
            try:
                mermaid_code = self._normalize_whitespace(mermaid_code)
                mermaid_code = self._remove_duplicate_nodes_fast(mermaid_code)
                # Extract just the flowchart declaration and first 300 lines
                flowchart_lines = []
                found_flowchart = False
                for line in lines:
                    if line.strip().startswith("flowchart"):
                        found_flowchart = True
                        flowchart_lines.append(line)
                    elif found_flowchart and len(flowchart_lines) < 300:
                        flowchart_lines.append(line)
                    elif found_flowchart and len(flowchart_lines) >= 300:
                        break
                if flowchart_lines:
                    mermaid_code = "\n".join(flowchart_lines)
            except Exception:
                # If even minimal repair fails, return truncated version
                return "\n".join(lines[:300]) if len(lines) > 300 else mermaid_code
            return mermaid_code
        
        # Normal repair for reasonably sized files
        try:
            # Single pass repair - optimized order
            mermaid_code = self._remove_duplicate_nodes_fast(mermaid_code)
            mermaid_code = self._normalize_whitespace(mermaid_code)
            mermaid_code = self._remove_undefined_references_fast(mermaid_code)
            mermaid_code = self._fix_invalid_edges_fast(mermaid_code)
            mermaid_code = self._ensure_start_end_nodes_fast(mermaid_code)
            mermaid_code = self._fix_decision_branches_fast(mermaid_code)
            mermaid_code = self._fix_node_syntax(mermaid_code)
            mermaid_code = self._normalize_whitespace(mermaid_code)
        except Exception as e:
            # If repair fails, return cleaned up version
            return self._normalize_whitespace(mermaid_code)
        
        return mermaid_code
    
    def _clean_markdown(self, code: str) -> str:
        """Remove markdown code blocks."""
        code = code.strip()
        if code.startswith("```"):
            lines = code.split("\n")
            if lines[0].strip() == "```" or lines[0].strip().startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            code = "\n".join(lines)
        return code.strip()
    
    def _remove_duplicate_nodes_fast(self, code: str) -> str:
        """Remove duplicate node definitions, keeping the best one."""
        lines = [l.strip() for l in code.split("\n") if l.strip()]
        seen_nodes = {}  # node_id -> (line_index, line_content, is_start_end_format)
        new_lines = []
        lines_to_skip = set()
        
        # First pass: identify all node definitions and mark duplicates
        for i, line in enumerate(lines):
            # Check if this is a node declaration
            # Pattern: ID[text] or ID{text} or ID([text]) or ID([Start]) or ID([End])
            node_match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\{|\(\[)', line)
            if node_match:
                node_id = node_match.group(1)
                is_start_end = bool(re.search(r'\(\[(Start|End)\]\)', line))
                
                if node_id in seen_nodes:
                    # Duplicate found - decide which one to keep
                    old_index, old_line, old_is_start_end = seen_nodes[node_id]
                    
                    # Prefer Start/End format: ([Start]) or ([End])
                    if is_start_end and not old_is_start_end:
                        # New one is better - mark old one for removal
                        lines_to_skip.add(old_index)
                        seen_nodes[node_id] = (i, line, is_start_end)
                    else:
                        # Old one is better or equal - mark new one for removal
                        lines_to_skip.add(i)
                else:
                    # First time seeing this node
                    seen_nodes[node_id] = (i, line, is_start_end)
        
        # Second pass: build new lines, skipping duplicates
        for i, line in enumerate(lines):
            if i not in lines_to_skip:
                new_lines.append(line)
        
        return "\n".join(new_lines)
    
    def _remove_undefined_references_fast(self, code: str) -> str:
        """Remove edges that reference undefined nodes - optimized single pass."""
        lines = [l.strip() for l in code.split("\n") if l.strip()]
        if len(lines) > 200:  # Skip on large files
            return code
        
        # Single pass: collect nodes and filter edges
        defined_nodes = set()
        label_keywords = {'Yes', 'No', 'YES', 'NO', 'True', 'False', 'TRUE', 'FALSE', 
                         'NEXT', 'END', 'case', 'default', 'Case', 'Default'}
        new_lines = []
        end_node_id = None
        
        for line in lines:
            # Check if it's a node definition
            node_match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\{|\(\[)', line)
            if node_match:
                node_id = node_match.group(1)
                defined_nodes.add(node_id)
                if re.search(r'\(\[End\]\)', line):
                    end_node_id = node_id
                new_lines.append(line)
                continue
            
            # Check if it's an edge
            if '-->' in line:
                # Try both patterns in one regex
                edge_match = re.search(r'^([A-Za-z0-9_]+)\s*-->(?:\|.*?\|)?\s*([A-Za-z0-9_]+)', line)
                if edge_match:
                    from_node = edge_match.group(1)
                    target_node = edge_match.group(2)
                    
                    # Handle label keywords
                    if target_node in ['NEXT', 'END'] and end_node_id:
                        line = re.sub(rf'-->\s*(?:\|.*?\|\s*)?{target_node}\b', f'--> {end_node_id}', line)
                        new_lines.append(line)
                        continue
                    
                    # Check if nodes are defined
                    if (from_node in defined_nodes and 
                        (target_node in defined_nodes or target_node in label_keywords)):
                        new_lines.append(line)
                    # Otherwise skip undefined edge
                else:
                    # Keep non-edge lines
                    new_lines.append(line)
            else:
                # Keep non-edge lines
                new_lines.append(line)
        
        return "\n".join(new_lines)
    
    def _fix_invalid_edges_fast(self, code: str) -> str:
        """Fix invalid edges (e.g., Start/End nodes with Yes/No branches)."""
        lines = code.split("\n")
        new_lines = []
        
        # Find Start and End nodes
        start_nodes = set()
        end_nodes = set()
        
        for line in lines:
            if re.search(r'\(\[Start\]\)', line):
                match = re.search(r'([A-Za-z0-9_]+)\(\[Start\]\)', line)
                if match:
                    start_nodes.add(match.group(1))
            if re.search(r'\(\[End\]\)', line):
                match = re.search(r'([A-Za-z0-9_]+)\(\[End\]\)', line)
                if match:
                    end_nodes.add(match.group(1))
        
        # Fix invalid edges
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Check for edges from Start with Yes/No labels
            for start_id in start_nodes:
                if line.startswith(start_id + " -->") and "|" in line:
                    # Remove the label, keep just the edge
                    line = re.sub(rf'{re.escape(start_id)}\s*-->\|.*?\|', f'{start_id} -->', line)
            
            # Check for edges to End with Yes/No labels
            for end_id in end_nodes:
                if f'-->|' in line and end_id in line:
                    # Check if target is End
                    if re.search(rf'-->\|.*?\|{re.escape(end_id)}', line):
                        # Remove the label
                        line = re.sub(r'-->\|.*?\|', '-->', line)
            
            new_lines.append(line)
        
        return "\n".join(new_lines)
    
    def _ensure_start_end_nodes_fast(self, code: str) -> str:
        """Ensure Start and End nodes exist - optimized single pass."""
        lines = [l.strip() for l in code.split("\n") if l.strip()]
        if len(lines) > 200:  # Skip on large files
            return code
        
        # Single pass: find Start/End nodes and track duplicates
        start_nodes = []
        end_nodes = []
        start_node_id = "S1"
        end_node_id = "E1"
        has_start = False
        has_end = False
        first_node = None
        lines_to_remove = set()
        
        for i, line in enumerate(lines):
            # Check for Start node
            start_match = re.search(r'([A-Za-z0-9_]+)\(\[Start\]\)', line)
            if start_match:
                node_id = start_match.group(1)
                if not has_start:
                    has_start = True
                    start_node_id = node_id
                else:
                    lines_to_remove.add(i)  # Duplicate
            
            # Check for End node
            end_match = re.search(r'([A-Za-z0-9_]+)\(\[End\]\)', line)
            if end_match:
                node_id = end_match.group(1)
                if not has_end:
                    has_end = True
                    end_node_id = node_id
                else:
                    lines_to_remove.add(i)  # Duplicate
            
            # Find first non-Start/End node
            if not first_node and not start_match and not end_match:
                node_match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\{|\(\[)', line)
                if node_match:
                    first_node = node_match.group(1)
        
        # Build new lines without duplicates
        new_lines = [line for i, line in enumerate(lines) if i not in lines_to_remove]
        
        # Add Start if missing
        if not has_start:
            start_line = f"{start_node_id}([Start])"
            # Insert after flowchart declaration
            for i, line in enumerate(new_lines):
                if line.strip().startswith("flowchart"):
                    new_lines.insert(i + 1, start_line)
                    if first_node:
                        new_lines.insert(i + 2, f"{start_node_id} --> {first_node}")
                    else:
                        new_lines.insert(i + 2, f"{start_node_id} --> {end_node_id}")
                    break
        
        # Add End if missing - simple approach
        if not has_end:
            end_line = f"{end_node_id}([End])"
            new_lines.append(end_line)
            # Connect last process node to End (simple heuristic)
            for line in reversed(new_lines):
                if re.search(r'^([A-Za-z0-9_]+)\[', line):
                    match = re.search(r'^([A-Za-z0-9_]+)\[', line)
                    if match and match.group(1) != start_node_id:
                        node_id = match.group(1)
                        # Check if it already has an outgoing edge
                        has_outgoing = any(f"{node_id} -->" in l for l in new_lines)
                        if not has_outgoing:
                            new_lines.append(f"{node_id} --> {end_node_id}")
                        break
        
        return "\n".join(new_lines)
    
    def _find_first_node(self, lines: List[str]) -> Optional[str]:
        """Find the first node in the flowchart (excluding Start/End)."""
        for line in lines:
            match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\{|\(\[)', line.strip())
            if match:
                node_id = match.group(1)
                if not re.search(r'Start|End', line, re.IGNORECASE):
                    return node_id
        return None
    
    def _find_nodes_needing_end(self, lines: List[str]) -> List[str]:
        """Find nodes that should connect to End (returns, final nodes)."""
        nodes_to_end = []
        all_nodes = set()
        nodes_with_outgoing = set()
        nodes_with_incoming = set()
        
        # Collect all nodes and their edges
        for line in lines:
            node_match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\{|\(\[)', line.strip())
            if node_match:
                node_id = node_match.group(1)
                if not re.search(r'Start|End', line, re.IGNORECASE):
                    all_nodes.add(node_id)
            
            edge_match = re.search(r'([A-Za-z0-9_]+)\s*-->(?:.*?\|)?\s*([A-Za-z0-9_]+)', line)
            if edge_match:
                from_node = edge_match.group(1)
                to_node = edge_match.group(2)
                nodes_with_outgoing.add(from_node)
                nodes_with_incoming.add(to_node)
        
        # Find return nodes (highest priority)
        for line in lines:
            if re.search(r'\(\[return', line, re.IGNORECASE):
                match = re.search(r'([A-Za-z0-9_]+)\(\[return', line, re.IGNORECASE)
                if match:
                    nodes_to_end.append(match.group(1))
        
        # Find nodes without outgoing edges
        for node in all_nodes:
            if (node not in nodes_with_outgoing and 
                node not in nodes_to_end):
                nodes_to_end.append(node)
        
        # Fallback
        if not nodes_to_end and all_nodes:
            process_nodes = []
            for line in lines:
                if re.search(r'\[', line) and not re.search(r'return|Start|End', line, re.IGNORECASE):
                    match = re.search(r'([A-Za-z0-9_]+)\[', line)
                    if match:
                        process_nodes.append(match.group(1))
            if process_nodes:
                nodes_to_end.append(process_nodes[-1])
            else:
                nodes_to_end.append(list(all_nodes)[0] if all_nodes else "S1")
        
        return nodes_to_end
    
    def _fix_decision_branches_fast(self, code: str) -> str:
        """Fix decision nodes missing Yes/No branches - optimized."""
        lines = [l.strip() for l in code.split("\n") if l.strip()]
        
        # Strict limit - skip on large files
        if len(lines) > 200:
            return code
        
        decision_nodes = {}
        node_edges = {}
        defined_nodes = set()
        
        # Find all decision nodes and defined nodes
        for line in lines:
            match = re.search(r'^([A-Za-z0-9_]+)\{.*?\}', line)
            if match:
                decision_id = match.group(1)
                decision_nodes[decision_id] = line
                defined_nodes.add(decision_id)
            
            # Also collect other node types
            node_match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\(\[)', line)
            if node_match:
                defined_nodes.add(node_match.group(1))
        
        # Single pass: collect edges for decision nodes
        for line in lines:
            edge_match = re.search(r'^([A-Za-z0-9_]+)\s*-->(.*)', line)
            if edge_match:
                from_node = edge_match.group(1)
                if from_node in decision_nodes:
                    if from_node not in node_edges:
                        node_edges[from_node] = []
                    node_edges[from_node].append(line)
        
        # Fix decision nodes missing branches
        new_lines = []
        nodes_added = set()
        
        for line in lines:
            new_lines.append(line)
            
            # Check if this is a decision node declaration
            match = re.search(r'^([A-Za-z0-9_]+)\{.*?\}', line)
            if match:
                decision_id = match.group(1)
                
                # Check if it has proper branches
                edges = node_edges.get(decision_id, [])
                has_yes = False
                has_no = False
                yes_target = None
                no_target = None
                
                for edge in edges:
                    if re.search(r'\|(Yes|YES|True|TRUE)\|', edge):
                        has_yes = True
                        target_match = re.search(r'-->\|.*?\|([A-Za-z0-9_]+)', edge)
                        if target_match and target_match.group(1) in defined_nodes:
                            yes_target = target_match.group(1)
                    elif re.search(r'\|(No|NO|False|FALSE)\|', edge):
                        has_no = True
                        target_match = re.search(r'-->\|.*?\|([A-Za-z0-9_]+)', edge)
                        if target_match and target_match.group(1) in defined_nodes:
                            no_target = target_match.group(1)
                
                # Fix missing branches
                if decision_id not in nodes_added:
                    nodes_added.add(decision_id)
                    
                    # Find valid target for missing branches
                    if not no_target:
                        next_node = self._find_next_valid_node_after(lines, line, defined_nodes, end_node_id)
                        if not has_no:
                            new_lines.append(f"{decision_id} -->|No| {next_node}")
                            has_no = True
                            no_target = next_node
                    
                    if not has_yes:
                        yes_target = self._find_yes_branch_target(lines, decision_id, no_target, defined_nodes)
                        if not yes_target:
                            yes_target = no_target
                        new_lines.append(f"{decision_id} -->|Yes| {yes_target}")
        
        return "\n".join(new_lines)
    
    def _find_next_valid_node_after(self, lines: List[str], current_line: str, 
                                    defined_nodes: Set[str], end_node_id: str) -> str:
        """Find the next valid node after current line."""
        current_index = -1
        for i, line in enumerate(lines):
            if line == current_line:
                current_index = i
                break
        
        if current_index >= 0:
            for i in range(current_index + 1, len(lines)):
                match = re.search(r'^([A-Za-z0-9_]+)(?:\[|\{|\(\[)', lines[i].strip())
                if match:
                    node_id = match.group(1)
                    if node_id in defined_nodes and not re.search(r'Start|End', lines[i], re.IGNORECASE):
                        return node_id
        
        return end_node_id
    
    def _find_yes_branch_target(self, lines: List[str], decision_id: str, no_target: str,
                                defined_nodes: Set[str]) -> Optional[str]:
        """Find target for Yes branch of a decision node."""
        # Look for unlabeled edge from this decision
        for line in lines:
            if line.strip().startswith(decision_id + " -->") and "|" not in line:
                target_match = re.search(r'-->\s*([A-Za-z0-9_]+)', line)
                if target_match and target_match.group(1) in defined_nodes:
                    return target_match.group(1)
        
        # Look for first process node after decision
        for line in lines:
            if decision_id in line:
                continue
            match = re.search(r'^([A-Za-z0-9_]+)\[', line.strip())
            if match and match.group(1) in defined_nodes:
                return match.group(1)
        
        return no_target if no_target in defined_nodes else None
    
    def _fix_node_syntax(self, code: str) -> str:
        """Fix common node syntax errors."""
        lines = code.split("\n")
        new_lines = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # Fix invalid syntax
            line = re.sub(r'start\(\[Start\]\)', 'S1([Start])', line, flags=re.IGNORECASE)
            line = re.sub(r'end\(\[End\]\)', 'E1([End])', line, flags=re.IGNORECASE)
            new_lines.append(line)
        
        return "\n".join(new_lines)
    
    def _ensure_connectivity(self, code: str) -> str:
        """Ensure all nodes are connected properly - simplified."""
        # Skip connectivity check - too expensive and rarely needed
        # The validator will catch connectivity issues
        return code
    
    def _normalize_whitespace(self, code: str) -> str:
        """Normalize whitespace in Mermaid code."""
        lines = []
        for line in code.split("\n"):
            line = line.strip()
            if line:
                lines.append(line)
        return "\n".join(lines)
    
    def _generate_empty_flowchart(self) -> str:
        """Generate a minimal valid flowchart."""
        return """flowchart TD
    S1([Start])
    E1([End])
    S1 --> E1"""
